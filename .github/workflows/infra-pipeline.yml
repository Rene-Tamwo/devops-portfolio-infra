name: Infrastructure Pipeline - Terraform & Ansible

on:
  push:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - 'ansible/**'
      - '.github/workflows/infra-pipeline.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - 'ansible/**'

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  CLUSTER_NAME: "devops-portfolio-cluster"

jobs:
  # Job 1: Validation Terraform
  terraform-validate:
    name: "Terraform Validate"
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with: 
        fetch-depth: 0 

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"

    - name: Terraform Format
      id: fmt
      run: |
        cd terraform
        terraform fmt -check -recursive

    - name: Terraform Init
      id: init
      run: |
        cd terraform
        # Utilise le lock file du repository
        terraform init -input=false -backend=false

    - name: Terraform Validate
      id: validate
      run: |
        cd terraform
        terraform validate

    - name: Terraform Plan
      id: plan
      run: |
        cd terraform
        terraform plan -input=false -var="aws_region=${{ secrets.AWS_REGION }}"
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}


  # Job 2: Déploiement Infrastructure (manuel pour sécurité)
  terraform-apply:
    name: "Terraform Apply"
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    outputs:
      master_ip: ${{ steps.tf-outputs.outputs.MASTER_IP }}
      worker_ip: ${{ steps.tf-outputs.outputs.WORKER_IPS }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with: 
        fetch-depth: 0

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"

    - name: Terraform Apply
      id: apply
      run: |
        cd terraform
        terraform init -input=false
        terraform apply -auto-approve -input=false -var="aws_region=${{ secrets.AWS_REGION }}"
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Get Terraform Outputs
      id: tf-outputs  # ⚠️ ID CORRECT : tf-outputs
      run: |
        cd terraform
        
        # 1. Récupérer l'IP du master
        MASTER_IP=$(terraform output -raw master_public_ip)
        echo "Master IP: $MASTER_IP"
        echo "MASTER_IP=$MASTER_IP" >> $GITHUB_OUTPUT
        
        # 2. Récupérer les IPs des workers (sous forme de JSON)
        WORKER_IPS_JSON=$(terraform output -json worker_public_ips)
        echo "Worker IPs JSON: $WORKER_IPS_JSON"
        
        # 3. Convertir JSON en liste simple (séparée par des espaces)
        WORKER_IPS_LIST=$(echo $WORKER_IPS_JSON | jq -r '.[]' | tr '\n' ' ' | sed 's/ $//')
        echo "Worker IPs List: $WORKER_IPS_LIST"
        echo "WORKER_IPS=$WORKER_IPS_LIST" >> $GITHUB_OUTPUT
        
        # 4. Sauvegarder la clé SSH
        terraform output -raw ssh_private_key > kubernetes-key.pem
        chmod 600 kubernetes-key.pem
        
        # 5. Afficher pour debug
        echo "=== DEBUG ==="
        echo "MASTER_IP from output: $MASTER_IP"
        echo "WORKER_IPS from output: $WORKER_IPS_LIST"
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Upload SSH Key
      uses: actions/upload-artifact@v4
      with:
        name: ssh-key
        path: terraform/kubernetes-key.pem
        retention-days: 1


  # Job 3: Configuration Ansible
  ansible-configure:
    name: "Ansible Configuration"
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download SSH Key
      uses: actions/download-artifact@v4
      with:
        name: ssh-key
        path: /tmp

    - name: Setup Ansible
      run: |
        sudo apt-get update
        sudo apt-get install -y ansible python3-pip
        pip3 install jmespath

    - name: Configure SSH
      run: |
        chmod 600 /tmp/kubernetes-key.pem
        mkdir -p ~/.ssh
        cp /tmp/kubernetes-key.pem ~/.ssh/
        echo "StrictHostKeyChecking no" >> ~/.ssh/config
        echo "UserKnownHostsFile /dev/null" >> ~/.ssh/config

    - name: Get IPs from Previous Job
      id: get-ips
      run: |
        # ⚠️ CORRECT : Utiliser needs.terraform-apply.outputs
        echo "Getting IPs from terraform-apply job..."
        echo "MASTER_IP=${{ needs.terraform-apply.outputs.master_ip }}" >> $GITHUB_ENV
        echo "WORKER_IPS=${{ needs.terraform-apply.outputs.worker_ips }}" >> $GITHUB_ENV

        # Debug
        echo "Master IP: ${{ needs.terraform-apply.outputs.master_ip }}"
        echo "Worker IPs: ${{ needs.terraform-apply.outputs.worker_ips }}"

    - name: Debug IPs
      run: |
        echo "=== DEBUG ENVIRONMENT ==="
        echo "MASTER_IP from env: $MASTER_IP"
        echo "WORKER_IPS from env: $WORKER_IPS"

        if [ -z "$MASTER_IP" ]; then
          echo "❌ ERROR: MASTER_IP is empty!"
          exit 1
        fi

    - name: Wait for instances to be ready
      run: |
        echo "⏳ Waiting for EC2 instances to be ready..."
        sleep 120  # Augmenté à 2 minutes

    - name: Generate Dynamic Inventory
      run: |
        cd ansible
        
        # ⚠️ CORRECT : Utiliser les variables d'environnement
        MASTER_IP="$MASTER_IP"
        # Convertir la chaîne d'IPs en tableau
        IFS=' ' read -r -a WORKER_IPS_ARRAY <<< "$WORKER_IPS"
        
        echo "Generating inventory with:"
        echo "Master: $MASTER_IP"
        echo "Workers: ${WORKER_IPS_ARRAY[@]}"
        
        cat > dynamic-inventory.ini << EOF
[master]
devops-portfolio-cluster-master ansible_host=$MASTER_IP ansible_user=ubuntu ansible_ssh_private_key_file=/tmp/kubernetes-key.pem

[workers]
EOF

        for i in "${!WORKER_IPS_ARRAY[@]}"; do
          echo "devops-portfolio-cluster-worker-$((i+1)) ansible_host=${WORKER_IPS_ARRAY[$i]} ansible_user=ubuntu ansible_ssh_private_key_file=/tmp/kubernetes-key.pem" >> dynamic-inventory.ini
        done

        cat >> dynamic-inventory.ini << EOF

[kube_cluster:children]
master
workers

[all:vars]
ansible_python_interpreter=/usr/bin/python3
ansible_ssh_common_args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
EOF

        echo "=== GENERATED INVENTORY ==="
        cat dynamic-inventory.ini

    - name: Test SSH Connection
      run: |
        echo "Testing SSH connection to master..."
        ssh -i /tmp/kubernetes-key.pem \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=30 \
            ubuntu@$MASTER_IP "echo '✅ SSH connection successful'" || echo "❌ SSH connection failed"


    - name: Run Ansible Playbook
      run: |
        cd ansible
        ansible-playbook -i dynamic-inventory.ini playbook.yml

    - name: Test Kubernetes Cluster
      run: |
        ssh -i /tmp/kubernetes-key.pem \
            -o StrictHostKeyChecking=no \
            ubuntu@$MASTER_IP "
          echo '=== Kubernetes Cluster Info ==='
          kubectl cluster-info
          echo ''
          echo '=== Nodes ==='
          kubectl get nodes
          echo ''
          echo '=== Pods ==='
          kubectl get pods --all-namespaces
        "

  # Job 4: Nettoyage (manuel)
  terraform-destroy:
    name: Destroy Infrastructure
    needs: ansible-configure
    runs-on: ubuntu-latest
    if: false  # Désactivé par défaut - à activer manuellement
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Terraform Destroy
      run: |
        cd terraform
        terraform init
        terraform destroy -auto-approve
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
