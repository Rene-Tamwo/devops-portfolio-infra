name: Infrastructure Pipeline - Terraform & Ansible

on:
  push:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - 'ansible/**'
      - '.github/workflows/infra-pipeline.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'terraform/**'
      - 'ansible/**'

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  CLUSTER_NAME: "devops-portfolio-cluster"

jobs:
  # Job 1: Validation Terraform
  terraform-validate:
    name: "Terraform Validate"
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"

    - name: Terraform Format
      id: fmt
      run: |
        cd terraform
        terraform fmt -check -recursive

    - name: Terraform Init
      id: init
      run: |
        cd terraform
        terraform init

    - name: Terraform Validate
      id: validate
      run: |
        cd terraform
        terraform validate

    - name: Terraform Plan
      id: plan
      run: |
        cd terraform
        terraform plan -var="aws_region=${{ secrets.AWS_REGION }}" -out=tfplan
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Upload Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan
        path: terraform/tfplan

  # Job 2: Déploiement Infrastructure (manuel pour sécurité)
  terraform-apply:
    name: "Terraform Apply"
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"

    - name: Download Terraform Plan
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan
        path: terraform

    - name: Terraform Apply
      id: apply
      run: |
        cd terraform
        terraform apply -auto-approve tfplan
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Get Terraform Outputs
      id: outputs
      run: |
        cd terraform
        echo "MASTER_IP=$(terraform output -raw master_public_ip)" >> $GITHUB_OUTPUT
        echo "WORKER_IPS=$(terraform output -json worker_public_ips | jq -r '.[]')" >> $GITHUB_OUTPUT
        terraform output -raw ssh_private_key > kubernetes-key.pem
        chmod 600 kubernetes-key.pem
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    - name: Upload SSH Key
      uses: actions/upload-artifact@v4
      with:
        name: ssh-key
        path: terraform/kubernetes-key.pem
        retention-days: 1

    - name: Save IPs to Environment
      run: |
        echo "MASTER_IP=${{ steps.outputs.outputs.MASTER_IP }}" >> $GITHUB_ENV
        echo "WORKER_IPS=${{ steps.outputs.outputs.WORKER_IPS }}" >> $GITHUB_ENV

  # Job 3: Configuration Ansible
  ansible-configure:
    name: "Ansible Configuration"
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download SSH Key
      uses: actions/download-artifact@v4
      with:
        name: ssh-key
        path: /tmp

    - name: Setup Ansible
      run: |
        sudo apt-get update
        sudo apt-get install -y ansible python3-pip
        pip3 install jmespath

    - name: Configure SSH
      run: |
        chmod 600 /tmp/kubernetes-key.pem
        mkdir -p ~/.ssh
        cp /tmp/kubernetes-key.pem ~/.ssh/
        echo "StrictHostKeyChecking no" >> ~/.ssh/config

    - name: Generate Dynamic Inventory
      run: |
        cd ansible
        # Remplacer les variables dans l'inventory
        MASTER_IP="${{ env.MASTER_IP }}"
        WORKER_IPS=(${{ env.WORKER_IPS }})
        
        cat > dynamic-inventory.ini << EOF
        [master]
        devops-portfolio-cluster-master ansible_host=$MASTER_IP ansible_user=ubuntu ansible_ssh_private_key_file=/tmp/kubernetes-key.pem

        [workers]
        EOF
        
        for i in "${!WORKER_IPS[@]}"; do
          echo "devops-portfolio-cluster-worker-$((i+1)) ansible_host=${WORKER_IPS[$i]} ansible_user=ubuntu ansible_ssh_private_key_file=/tmp/kubernetes-key.pem" >> dynamic-inventory.ini
        done
        
        echo "" >> dynamic-inventory.ini
        echo "[kube_cluster:children]" >> dynamic-inventory.ini
        echo "master" >> dynamic-inventory.ini
        echo "workers" >> dynamic-inventory.ini
        echo "" >> dynamic-inventory.ini
        echo "[all:vars]" >> dynamic-inventory.ini
        echo "ansible_python_interpreter=/usr/bin/python3" >> dynamic-inventory.ini
        echo "ansible_ssh_common_args='-o StrictHostKeyChecking=no'" >> dynamic-inventory.ini

    - name: Wait for instances to be ready
      run: |
        echo "⏳ Waiting for EC2 instances to be ready..."
        sleep 60

    - name: Run Ansible Playbook
      run: |
        cd ansible
        ansible-playbook -i dynamic-inventory.ini playbook.yml

    - name: Test Kubernetes Cluster
      run: |
        ssh -i /tmp/kubernetes-key.pem -o StrictHostKeyChecking=no ubuntu@${{ env.MASTER_IP }} "
          kubectl cluster-info
          kubectl get nodes
          kubectl get pods --all-namespaces
        "

  # Job 4: Nettoyage (manuel)
  terraform-destroy:
    name: "Terraform Destroy"
    runs-on: ubuntu-latest
    if: true  # Désactivé par défaut - à activer manuellement
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Terraform Destroy
      run: |
        cd terraform
        terraform init
        terraform destroy -auto-approve
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
